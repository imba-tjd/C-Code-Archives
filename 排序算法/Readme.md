# 本部分代码的特点

* 参数中的数组
  * 如果只有一个数组，顺序为arr, len或arr, from, to；前者必为左闭右开，后者必不把数组进行指针算数运算
  * 如果有两个以上数组，顺序为len1, arr1[len1], len2, arr2[len2]，不把数组进行指针算数运算
  * 偶尔有C++风格：arr, *end
* 使用了VLA
* 测试用的数组长度是硬编码的10，不打算用sizeof(arr)/sizeof(*arr)；数据也是硬编码的随机数据，不打算从用户处读入
* 参数类型硬编码为int
* 升序排序，从小到大

总之重点在于排序的思想。

测试用例：https://www.nowcoder.com/practice/2baf799ea0594abd974d37139de27896

## 插值查找法

类似于二分查找，也是要求数组有序，它还期望数据尽量均匀分布。先计算n/(arr[n-1]-arr[0])，即假定完全均匀分布时一单位的数据等于多少索引，再乘以target-arr[0]，得到起始索引，之后递归差值，往target靠。其中后者的乘可放在前者的前面，就不用1.0*n了

## 广义二分查找

当某个点能将区间划分为具有不同性质的两部分时，想找到那个点，就可以用二分。\
但是对于离散的点，性质边界上有两个点分别属于不同的性质。\
对于闭区间：\
如果将前半部分视为满足，则最终找到的是满足区间最后的点；如果将后半部分视为满足，则最终找到满足区间最前面的点。\
对于前者，如果mid满足，即mid在前半部分，那要找的答案就在mid及后面，因此更新区间 l=mid, else r=mid-1。\
对于后者，如果mid满足，即在后半部分，那要找的答案在前面，r=mid, else l = mid+1。\
且对于前者，要mid = l+r+1 >> 2，否则某些时候区间将不变导致死循环。\
循环条件：l < r 或 l != r，即出循环时l == r，区间长度1。得到的边界不一定符合题目的要求，可能题目上无解，但一定能得到边界。

例子：1 2 2 3 3 4，找出值等于q的区间（起始结束下标），如2的区间是[1,2]。分别找起始点(x>=2)就是后者，结束点(x<=2)就是前者。
